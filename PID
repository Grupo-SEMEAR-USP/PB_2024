//PID.h

#include "h_bridge.h"
#include "esp_err.h"

#define VAL_BASE 100 // ??

// (Atualizar par창metros)
#define KP_R 0.1
#define KI_R 0
#define KD_R 0
#define MAX_OUTPUT_R 100000 //?
#define MIN_OUTPUT_R 0 //?
#define MAX_OUTPUT_R 2046 
#define MIN_OUTPUT_R 0 
#define MAX_INTEGRAL_R 100000  //limita a range da soma dos erros (s처 importa se usar PID_CAL_TYPE_POSITIONAL)
#define MIN_INTEGRAL_R 0

#define KP_L 0.1
#define KI_L 0
#define KD_L 0
#define MAX_OUTPUT_L 100000
#define MAX_OUTPUT_L 2046
#define MIN_OUTPUT_L 0
#define MAX_INTEGRAL_L 100000 
#define MIN_INTEGRAL_L 0
@@ -34,6 +32,6 @@
#define min_integral(SIDE) (SIDE == MOTOR_RIGHT)? MIN_INTEGRAL_R : MIN_INTEGRAL_L

pid_ctrl_block_handle_t init_pid(type_side_motor motor);
esp_err_t apply_pid(pid_ctrl_block_handle_t pid, type_side_motor motor, pcnt_unit_handle_t encoder, float target_vel);
esp_err_t pid_apply(float* val_incrementado, pid_ctrl_block_handle_t pid, type_side_motor motor, pcnt_unit_handle_t encoder, float target_vel);

#endif


//PID.c

#include "pid.h"

const char *TAG_PID = "Pid";

// void teste(){

//     float error, result; //(inicializar)
@@ -20,7 +22,7 @@ pid_ctrl_block_handle_t init_pid(type_side_motor motor){
        .min_output = min_output(motor),
        .max_integral = max_integral(motor),
        .min_integral = min_integral(motor),
        .cal_type = PID_CAL_TYPE_POSITIONAL //(ou incremental?)
        .cal_type = PID_CAL_TYPE_INCREMENTAL //(ou incremental?)
    };

    pid_ctrl_config_t pid_config = {
@@ -34,19 +36,28 @@ pid_ctrl_block_handle_t init_pid(type_side_motor motor){
    return pid;
}

esp_err_t apply_pid(pid_ctrl_block_handle_t pid, type_side_motor motor, pcnt_unit_handle_t encoder, float target_vel){
    
    //como vai ser aplicado o delay?

    float k = 0.02; // constante de convers찾o ticks x rpm 
    float vel_atual = pulse_count(encoder) * k;
//limites do PWM
void limit_PWM(float *val, float target_vel){
    if(*val > 1023) *val = 1023;
    if(*val < 0 && target_vel >= 0) *val = 0; //se velocidade alvo for positiva
    else if(*val < -1023 && target_vel < 0) *val = -1023; //se for negativa
}

esp_err_t pid_apply(float* val_incrementado, pid_ctrl_block_handle_t pid, type_side_motor motor, pcnt_unit_handle_t encoder, float target_vel){

    float k = 1; // constante de convers찾o ticks x rpm 
    float vel_atual = pulse_count(encoder) * k; //delay de 50ms
    float erro = target_vel - vel_atual;

    //calcula e aplica pid
    float result;
    ESP_ERROR_CHECK(pid_compute(pid, erro, &result));
    update_motor(motor, result + VAL_BASE);
    result *= (1/k);
    *val_incrementado += result;

    limite_PWM(&val_incrementado, target_vel);
    update_motor(motor, val_incrementado);

    ESP_LOGI(TAG_PID, "Alvo: %f  Erro: %f  PID: %f\n", target_vel, erro, val_incrementado);
    return ESP_OK;
}
